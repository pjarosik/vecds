// Class automatically generated by Dev-C++ New Class wizard

#ifndef CXML_H
#define CXML_H

#include "xml_parameter.h"
#include "xml_element.h"
#include "xml_outputdevice.h"
#include "xml_inputdevice.h"
#include "xml_creator.h"
#include "xml_remark.h"
#include "xml_node.h"
#include "xml_preprocessing.h"
#include "xml_cdata.h"
#include "xml_doctype.h"
#include "xml_header.h"
#include "xml_text.h"

#include <string>
#include <list>
using namespace std;

/**
 * No description
 */
 
class CXML
{
	public:
		// class constructor
		CXML(  ):main_element(0),current_node(0),current_element(0)  { }
		void  CreateMainNode( const string &me ) { OpenNode( me ); main_element = current_node; }
		void  OpenNode( const string &elem );
		void  AddParameter( const string &name, const string &value );
		void  AddCDATA( const string &value );
		void  AddRemark( const string &rem );
		void  AddHeader( const string &hdata );
		void  AddText( const string &tx );
		void  AddPreprocessing( const string &name, const string &cn );
		void  AddDOCTYPE( const string &nm, bool p, const string &i );
		void  CloseNode( const string &nm );
		const CXML_Node* GetCurrentNode() const { return current_node; }
		const CXML_Element& GetMainElement() const { return *main_element; }
		const ListOfElements& GetElements() const { return elements; }
		void FindNodes( const string &filter, vector< const CXML_Node * > &nodes ) const;

		void Create( CXML_Creator &creator );
		// class destructor
		virtual ~CXML();
		void Reset();
protected:
	list< CXML_Node* >   queue_elems;
	ListOfElements       elements;
	CXML_Element 		 *main_element, *current_element;
	CXML_Node    		 *current_node;
	void CreateElement( CXML_Creator &creator, const CXML_Element &elem ) const;
		// The function creates an element in xml file
};

inline void CXML::OpenNode( const string &elem_name )
{ 
    if ( main_element && queue_elems.empty() ) throw CXML_Exception("main element already exists");
    CXML_Node *elem = new CXML_Node( elem_name );
    if ( !main_element )  elements.push_back( elem );
    queue_elems.push_back( elem ) ;
    if ( current_node ) current_node->AddElement( elem );
    current_node = elem;
    main_element = elem;
}

inline void CXML::CloseNode( const string &nm )
{
	if ( nm == "xml" ) 
	{
		if ( !current_element ) CXML_Exception("current node is empty. Cannot close header");
		if ( current_element->GetName()!="xml" ) CXML_Exception("Cannot close header. Current node name is:" + current_element->GetName() );
		current_element = 0;
	}
	else {
		if ( queue_elems.empty( ) ) throw CXML_Exception("elements stack is empty");
		if ( nm.length() && nm != queue_elems.back()->GetName() ) CXML_Exception("wrong name of element to close");
		queue_elems.pop_back( );
		if ( queue_elems.empty( ) ) current_node = 0;
		else current_node = queue_elems.back( );
	}
}

inline void CXML::AddParameter( const string &name, const string &value )
{ 
	if ( current_node )	current_node->AddParameter( new CXML_Parameter( name, value ) );
}

inline void CXML::AddCDATA( const string &cdata )
{
    if ( current_node )	current_node->AddElement( new CXML_CDATA( cdata ) );
    else elements.push_back( new CXML_CDATA( cdata ) );
}

inline void CXML::AddText( const string &tx )
{
    if ( current_node )	current_node->AddElement( new CXML_Text( tx ) );
    else throw CXML_Exception( "Text can't be inserted at the top level" );
}

inline void CXML::AddHeader( const string &hdata )
{
	if ( current_node )	CXML_Exception( "Header should be inserted at the top level" );
	current_element = dynamic_cast<CXML_Element*>( new CXML_Header( hdata ) );
    elements.push_back( new CXML_Header( hdata ) );
}

inline void CXML::AddDOCTYPE( const string &nm, bool p, const string &i )
{
	if ( current_node )	current_node->AddElement(  new CXML_DOCTYPE( nm, p, i ) );
    else elements.push_back( new CXML_DOCTYPE( nm, p, i ) );
}

inline void CXML::AddPreprocessing( const string &name, const string &cn )
{
    if ( current_node )	current_node->AddElement( new CXML_Preprocessing(name, cn ) );
    else elements.push_back( new CXML_Preprocessing( name, cn ) );
}

inline void CXML::AddRemark( const string &rem )
{
    if ( current_node )	current_node->AddElement( new CXML_Remark( rem ) );
    else elements.push_back( new CXML_Remark( rem ) );
}

#endif // CXML_H
