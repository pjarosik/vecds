// Class automatically generated by Dev-C++ New Class wizard

#ifndef CXML_ANALYSER_H
#define CXML_ANALYSER_H

#include "xml_inputdevice.h"
#include "xml_tokenizer.h"
#include "../XMLLib/xml_charvalidators.h"
#include <vector>
#include <iostream>
using namespace std;

/**
 * Analyser class. Analysing an xml file and creating apropriate events by calling member functions of a receiver R.
   The events correspond appropriate elements of XML language are listed below.
 */
 
/* The following members should be provided by template argument R so called receiver

  	    void  OpenNode( const string &elem );
		void  AddParameter( const string &name, const string &value );
		void  AddCDATA( const string &value );
		void  AddRemark( const string &rem );
		void  AddHeader( const string &hdata );
		void  AddText( const string &tx );
		void  AddPreprocessing( const string &name, const string &cn );
		void  AddDOCTYPE( const string &nm, bool p, const string &i );
		void  CloseNode( const string &nm );

*/

	/*
	XML_NODE,
    XML_PARAMETER,
	XML_HEADER,
	XML_PREPROCESSING,
	XML_REMARK,
	XML_CDATA,
	XML_DOCTYPE,
	XML_TEXT,
	*/

		
template<class R>
class CXML_Analyser
{
	public:
		// class constructor
		CXML_Analyser( istream &i, R &rc ):inp( i ), receiver( rc ),main_element(false), is_header(false), is_doctype(false) { }
		void ReadXMLFile();
		// class destructor
		~CXML_Analyser() { }

protected:
	
	bool main_element, is_header, is_doctype;
	istream &inp;
	R   &receiver;
    vector<string>   nodes_stack;

	CXML_Analyser( ) {  }
	void ProcessFile( );
	void ReadPreprocessing();
	bool ReadXMLParameter( string &param, string &value );
};

template<class R>
void CXML_Analyser<R>::ReadXMLFile()
{
	main_element = false;
	ProcessFile( );
}

template<class R>
bool CXML_Analyser<R>::ReadXMLParameter( string &param, string &value )
{
	char c;
	XmlTokenizer< ValidXMLAttributeName > attr_tokenizer( inp );
	XmlTokenizer< ValidNotChar<'"'> > str_tokenizer1( inp );
	XmlTokenizer< ValidNotChar<'\''> > str_tokenizer2( inp );

	attr_tokenizer >> param;
	if ( !param.size() ) return false;

	attr_tokenizer.ReadChar( '=' );
	c = attr_tokenizer.ReadChar( "\"\'" );
	if ( c == '\"' ) str_tokenizer1 >> value;
	else str_tokenizer2 >> value;
	attr_tokenizer.GetChar( c );
	return true;
}

template<class R>
void CXML_Analyser<R>::ProcessFile( )
{
	XmlTokenizer< ValidXMLNodeName > name_tokenizer( inp );
	XmlTokenizer< ValidXMLText > text_tokenizer( inp );
	string text, token, param, value;
	char c, c1;
	inp >> c;
	while ( !inp.eof( ) )
	{

		switch( c )
		{
			case '<' :	c1 = inp.get(); 
						switch ( c1 )
						{
							case '?' :	name_tokenizer >>  token;
										receiver.AddHeader( "" );
										while ( ReadXMLParameter( param, value ) )
											receiver.AddParameter( param, value );
										name_tokenizer.ReadString("?>");
										receiver.CloseNode("xml");
										break;
							case '!' :  break;
							case '/' :	name_tokenizer >>  token;
										receiver.CloseNode( token );
										name_tokenizer.ReadChar( '>' );
										break;
							default  :	name_tokenizer >>  token;
										receiver.OpenNode( c1 + token );			
										while ( ReadXMLParameter( param, value ) )
											receiver.AddParameter( param, value );
										c1 = name_tokenizer.ReadChar( "/>" );
										if ( c1=='/' ) 
										{
											receiver.CloseNode( "" );
											name_tokenizer.GetChar( '>' );
										}
										break;
						};
						break;
			default :	inp.putback( c );
						text_tokenizer >> text;
						receiver.AddText( text );
						break;
		};
		inp >> c;
	}
}



#endif // CXML_ANALYSER_H
