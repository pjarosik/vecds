// Class automatically generated by Dev-C++ New Class wizard

#include "BoxPlot.h" // class's header file
#include <vector>
#include <algorithm>
#include "pen.h"

using namespace std;

// class constructor

CBoxPlot::CSetup::CSetup()
{
    bx = by = 2.0;
    ex = ey = 2.0;
    ny = 2.0;
    bny = 1.0;
	bc = 0.5;
    desc_font_height = 1.5;
	box_values_font_height = 1.0;
	default_pen = DPen( DColor(0, 0, 0), 0, 1.5 );
	default_brush = DBrush( DColor(150, 150, 150), 0);
}

CBoxPlot::CBoxPlot( double x, double y, double w, double h, double a ):CPaintFrame( x, y, w, h ),aspect( a )
{
	plot_description = "bar plot";
}

void CBoxPlot::Paint( CGraphDevice &gDV ) const
{
	if ( !box_values.size() ) return;
	unsigned k,l;
    gDV.Rectangle( xs(0), ys(0), xs(100.0), ys( aspect  * 100.0 ) ); // - for testing only

    double tscale=scale(), h_size, plot_height = 100 * aspect , ox, oy, plot_area_width, plot_area_height, arrow = 5.0;

// Dimeension of plot elements calculations

	double hmin=1.e300, hmax=-1.e300, dvalue = 0.0;

	for (k=0; k<box_values.size(); k++)
	{
		if ( box_values[ k ].max > hmax ) hmax = box_values[ k ].max;
		if ( box_values[ k ].min < hmin ) hmin = box_values[ k ].min;
	}

	string stmin,stmax;
	stringstream sst;
	sst << hmin;
	stmin = sst.str();
	stringstream sst1;
	sst1 << hmax;
	stmax = sst1.str();
	// if ( hmin > 0.0 ) hmin = 0.0;
	// if ( hmax < 0.0 ) hmax = 0.0;
	
	dvalue = hmax - hmin;
	
	if ( dvalue == 0.0 ) return;

	ox = setup.bx;
	oy = setup.by + setup.desc_font_height + setup.ny;
	plot_area_width = 100 -  setup.bx - setup.ex;
	plot_area_height= plot_height - oy - setup.ey - 2 * ( setup.box_values_font_height + setup.bny ) ;
	
    gDV.AssignFont( "Arial", scale( setup.desc_font_height ) );
    h_size = gDV.GetTextWidth( plot_description.c_str( ) ) / tscale;
    gDV.Write2D( xs( ox + ( 100 - setup.ex - ox - h_size ) / 2.0   ), ys( setup.by ), plot_description.c_str( ) );

// box painting

	double cy = plot_area_height / dvalue;
	double box_place_width = plot_area_width / (double)box_values.size(), box_width = box_place_width * setup.bc;
	double zero_pos_y = oy + setup.box_values_font_height + setup.bny - hmin * cy;

	gDV.SetPen( setup.default_pen );
	gDV.SetBrush( setup.default_brush );
	gDV.AssignFont( "Arial", scale( setup.box_values_font_height ) );

    gDV.Line2D( xs( setup.bx ),ys( zero_pos_y + hmin * cy ),xs( setup.bx  ),ys( zero_pos_y + hmax * cy ) );
    gDV.Write2D( xs( setup.bx  ), ys( zero_pos_y + hmin * cy  ) - gDV.GetFontHeight(  ) , stmin.c_str( ) );
    gDV.Write2D( xs( setup.bx  ), ys( zero_pos_y + hmax * cy ), stmax.c_str( ) );
	
	gDV.SetPredefinedBrush( BRUSH_HOLLOW );
//	gDV.SetPredefinedPen( PEN_THICK_LIGHTGRAY );
    gDV.Line2D( xs( ox ),ys( zero_pos_y ),xs( ox + plot_area_width  ),ys( zero_pos_y ) );

	double xbc,xb1,xb2,yb, dsize, mv,q1,q2,q3,ym, dq, dm = box_width / 30.0, sy;
	for ( k=0; k<box_values.size(); k++)
	{
		gDV.SetPredefinedPen( PEN_BLUE );
		xbc = ox + ( (double)k + 0.5 ) * box_place_width;
		xb1 = xbc - box_width / 2.0;
		xb2 = xb1 + box_width;
		dq = box_values[ k ].q75  - box_values[ k ].q25;
		yb = zero_pos_y + box_values[ k ].max * cy;
		mv = zero_pos_y + box_values[ k ].mv * cy;
		q1 = zero_pos_y + box_values[ k ].q25 * cy;
		q2 = zero_pos_y + box_values[ k ].q50 * cy;
		q3 = zero_pos_y + box_values[ k ].q75 * cy;
		ym = zero_pos_y + box_values[ k ].min * cy;
		if ( ( box_values[ k ].max - box_values[ k ].q75 ) > 1.5 * dq ) yb = zero_pos_y + ( 1.5 * dq + box_values[ k ].q75 ) * cy;
		if ( ( box_values[ k ].q25 - box_values[ k ].min ) > 1.5 * dq ) ym = zero_pos_y + ( box_values[ k ].q25 - 1.5 * dq + box_values[ k ].q75 ) * cy;
//		gDV.Rectangle( xs( xb1 ), ys( zero_pos_y ), xs( xb2 ), ys( yb ) );
        gDV.Line2D( xs( xbc ), ys( ym ), xs( xbc ), ys( yb ) );
        gDV.Line2D( xs( xb1 ), ys( ym ), xs( xb2 ), ys( ym ) );
        gDV.Line2D( xs( xb1 ), ys( yb ), xs( xb2 ), ys( yb ) );
		gDV.Rectangle( xs( xb1 ), ys( q1 ), xs( xb2 ), ys( q3) );
        gDV.Line2D( xs( xb1 ), ys( q2 ), xs( xb2 ), ys( q2 ) );
		for (l=0; l<box_values[k].samples->size(); l++)
		{
			sy = (*box_values[k].samples)[l];
			if ( ( ( sy - box_values[ k ].q75 ) > 1.5 * dq ) || ( ( box_values[ k ].q25 - sy  ) > 1.5 * dq ) )
				if ( ( ( sy - box_values[ k ].q75 ) > 3.0 * dq ) || ( ( box_values[ k ].q25 - sy  ) > 3.0 * dq ) )
				{
					stringstream sst;
					sst << sy;
                    gDV.Write2D( xs( xbc  ), ys( zero_pos_y + sy * cy ), sst.str().c_str( ) );
					gDV.SetPredefinedPen( PEN_LIGHTRED );
                    gDV.Line2D( xs( xbc-dm ), ys( zero_pos_y + sy * cy-dm ), xs( xbc+dm ), ys( zero_pos_y + sy * cy+dm ) );
                    gDV.Line2D( xs( xbc-dm ), ys( zero_pos_y + sy * cy+dm ), xs( xbc+dm ), ys( zero_pos_y + sy * cy-dm ) );
				}
				else
				{
				//	stringstream sst;
				//	sst << sy;
				//	gDV.Write( xs( xbc  ), ys( zero_pos_y + sy * cy ), sst.str().c_str( ) );

					gDV.SetPredefinedPen( PEN_LIGHTGREEN );
					gDV.Ellipse( xs( xbc-dm ), ys( zero_pos_y + sy * cy-dm ), xs( xbc+dm ), ys( zero_pos_y + sy * cy+dm ) );
					gDV.Ellipse( xs( xbc-dm ), ys( zero_pos_y + sy * cy+dm ), xs( xbc+dm ), ys( zero_pos_y + sy * cy-dm ) );
				}

		}
		gDV.SetPen( DPen( DColor( 128, 128, 128 ), 0, 4 ) );
        gDV.Line2D( xs( xb1 ), ys( mv ), xs( xb2 ), ys( mv ) );
		dsize = gDV.GetTextWidth( box_values[k].box_descriptions.c_str( ) ) / tscale;
        if ( box_values[k].max >= 0.0 ) gDV.Write2D( xs( xbc -  dsize / 2.0 ), ys( yb + 0.1 ), box_values[k].box_descriptions.c_str( ) );
        else gDV.Write2D( xs( xbc -  dsize / 2.0 ), ys( yb - 0.1 - setup.box_values_font_height ), box_values[k].box_descriptions.c_str( ) );
		gDV.SetPen( setup.default_pen );
	}
	
	gDV.SetPredefinedPen( PEN_BLACK );
}
