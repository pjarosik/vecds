// Class automatically generated by Dev-C++ New Class wizard

#include "GraphReceiverXML.h" // class's header file
#include "../XMLLib/xml_exceptions.h"
#include <cstdlib>
// class constructor
xml_GraphReceiver::xml_GraphReceiver(CGraphDevice *g):gDC( g ),initialized( false ),
										pen_array_mode( false ), brush_array_mode( false ),
										point_mode( false )
{
	// insert your code here
}

// class destructor
xml_GraphReceiver::~xml_GraphReceiver()
{
	// insert your code here
}

void  OpenNode( const string &elem );

void  xml_GraphReceiver::OpenNode( const string &elem )
{
	if ( initialized )
	{
   		if ( current_node == "polygon"	)			{ point_mode=true;	points.clear(); return ; }
   		if ( current_node == "polyline"	)			{ point_mode=true;	points.clear(); return ; }
   		if ( current_node == "create_brush_array" )		{ brush_array_mode=true;	brush_array.clear(); return ; }
		if ( current_node == "create_pen_array"	  )		{ pen_array_mode=true;		pen_array.clear(); return ; }

		current_node = elem;
//		throw CXML_Exception((string)"Graphic file: Unknown node :" + elem );
	}
	else if ( elem == "graphics" ) initialized = true;
		 else throw CXML_Exception("Main node <graphics> is expected instead of :" + elem );
}

void  xml_GraphReceiver::AddParameter( const string &name, const string &value )
{
}

void  xml_GraphReceiver::AddCDATA( const string &value )
{
}

void  xml_GraphReceiver::AddRemark( const string &rem )
{
}

void  xml_GraphReceiver::AddHeader( const string &hdata )
{
}

void  xml_GraphReceiver::AddText( const string &tx )
{
	char *err=0;
	const char *ctx = tx.c_str();
	if ( current_node == "x1" ) { x1 = strtod( tx.c_str(), &err ); return; }
	if ( current_node == "y1" ) { y1 = strtod( tx.c_str(), &err ); return; }
	if ( current_node == "x2" ) { x2 = strtod( tx.c_str(), &err ); return; }
	if ( current_node == "y2" ) { y2 = strtod( tx.c_str(), &err ); return; }
	if ( current_node == "x" ) { x = strtod( tx.c_str(), &err ); return; }
	if ( current_node == "y" ) { y = strtod( tx.c_str(), &err ); return; }
	

	if ( current_node == "text" ) { text = tx; return ; }

	if ( current_node == "brush_index"	) { brush_index	= atoi( tx.c_str()  ); return; }
	if ( current_node == "pen_index"	) { pen_index	= atoi( tx.c_str()  ); return; }
	if ( current_node == "height"		) { height		= strtod( tx.c_str(), &err ); return; }
	if ( current_node == "width"		) { width		= strtod( tx.c_str(), &err ); return; }
	if ( current_node == "thickness"	) { thickness	= strtod( tx.c_str(), &err ); return; }
	if ( current_node == "color_index"	) { color_index	= atoi( tx.c_str()  ); return ; }
	if ( current_node == "style"		) { style = atoi( tx.c_str()  ); return ; }
	if ( current_node == "R"			) { R = atoi( tx.c_str()  ); return ; }
	if ( current_node == "G"			) { G = atoi( tx.c_str()  ); return ; }
	if ( current_node == "B"			) { B = atoi( tx.c_str()  ); return ; }
	if ( current_node == "face"			) { face = tx; return ; }
	
	if ( current_node == "ax" ) { ax = strtod( tx.c_str(), &err ); return; }
	if ( current_node == "ay" ) { ay = strtod( tx.c_str(), &err ); return; }

	if (!err) throw CXML_Exception((string)"double value is expected instead of :" + tx);
}

void  xml_GraphReceiver::AddPreprocessing( const string &name, const string &cn )
{
}

void  xml_GraphReceiver::AddDOCTYPE( const string &nm, bool p, const string &i )
{
}

void  xml_GraphReceiver::CloseNode( const string &nm )
{
    if ( nm == "line" )						{ gDC->Line2D(x1,y1,x2,y2); return; }
	if ( nm == "point"	)					{ point = DPoint2D(x,y); if ( point_mode ) points.push_back( point ); return;  }
	if ( nm == "rectangle" )					{ gDC->Rectangle(x1,y1,x2,y2); return; }
    if ( nm == "polyline"	)				{ gDC->Polyline2D( points ); point_mode = false; return; }
    if ( nm == "polygon"	)				{ gDC->Polygon2D( points );  point_mode = false; return; }
	if ( nm == "set_predefined_pen" )			{ gDC->SetPredefinedPen( pen_index ); return ; }
	if ( nm == "set_predefined_brush" )		{ gDC->SetPredefinedBrush( brush_index ); return; }
	if ( nm == "select_array_brush" )			{ gDC->SelectArrayBrush( brush_index ); return; }
	if ( nm == "select_array_pen" )			{ gDC->SelectArrayBrush( pen_index ); return; }
	if ( nm == "set_aspect" )				{ gDC->SetAspect(ax,ay); return; }
	if ( nm == "set_brush" )					{ gDC->SetBrush( brush ); return; }
	if ( nm == "set_pen" )					{ gDC->SetPen( pen ); return; }
	if ( nm == "set_font_height" )			{ gDC->SetFontHeight( height ); return; }
//	if ( nm == "set_text_color" )				{ gDC->SetTextColor( col ); return; }
//	if ( nm == "set_predefined_text_color" )	{ gDC->SetPredefinedTextColor( color_index ); return; }
	if ( nm == "pen" )						{ pen = DPen( col, style, thickness ); if (pen_array_mode) pen_array.push_back( pen ); return; }
	if ( nm == "brush" )					{ brush = DBrush( col, style ); if (brush_array_mode) brush_array.push_back( brush ); return; }
	if ( nm == "color" )					{ col = DColor( R, G, B ); return; }
	if ( nm == "create_brush_array")			{ gDC->CreateBrushArray( brush_array ); brush_array_mode = false; return; }
	if ( nm == "create_pen_array"	)			{ gDC->CreatePenArray( pen_array ); pen_array_mode = false; return; }
	if ( nm == "assign_font" )				{ gDC->AssignFont( face.c_str(), height); return ; }
	if ( nm == "set_hollow_brush" )			{ gDC->SetHollowBrush(); return ; }
	if ( nm == "set_null_pen" )				{ gDC->SetNullPen(); return ; }
//	if ( nm == "set_xor_mode" )				{ gDC->SetXORMode(); return ; }
//	if ( nm == "set_put_mode" )				{ gDC->SetPutMode(); return ; }
//	if ( nm == "set_bk_transparent_mode" )		{ gDC->SetBkTransparentMode(); return ; }
}
