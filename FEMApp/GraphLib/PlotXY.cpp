// Class automatically generated by Dev-C++ New Class wizard

#include "PlotXY.h" // class's header file
#include <cassert>

// class constructor

CPlotXY::CSetup::CSetup()
{
	type = PLT_FRAME1;
	bx = by = 2.0;
	ex = ey = 2.0;
	nx = 2.0;
	ny = 2.0;
	amx = 1.0;
	amy = 1.0;
	desc_font_height  = 1.5;
	value_font_height = 1.0;
	lines_font_height = 1.0;
	vx_frm = vy_frm = "%4.3f";
   	div_x = 5;
	div_y = 4;
	find_desc_pos = true;
	desc_x = 0.5;
	desc_y = 0.5;
	has_description = true;
	has_scale_x = has_scale_y = true;
	scale_x_significand_digit_paint = 3;
	scale_y_significand_digit_paint = 3;
}

CPlotXY::Transformation::Transformation( const CMaxMin &maxs, double plot_area_width, double plot_area_height )
{
	cx  = plot_area_width / maxs.GetDiff( 0 );
	cy  = plot_area_height / maxs.GetDiff( 1 );
	lpx = maxs.GetMin( 0 );
	lpy = maxs.GetMin( 1 );
}


CPlotXY::CPlotXY( const CPlotXY &pl )
{
	setup  = pl.setup;
	aspect = pl.aspect;
	lines  = pl.lines;
	rmin   = pl.rmin;
	rmax   = pl.rmax;
	IsRangeEnforced = pl.IsRangeEnforced;
	x_description = pl.x_description;
	y_description = pl.y_description;
}

const CPlotXY& CPlotXY::operator=( const CPlotXY &pl )
{
    setup = pl.setup;
	aspect = pl.aspect;
	lines = pl.lines;
	x_description = pl.x_description;
	y_description = pl.y_description;
	rmin   = pl.rmin;
	rmax   = pl.rmax;
	IsRangeEnforced = pl.IsRangeEnforced;
	return pl;
}


CPlotXY::CPlotXY( double x, double y, double w, double h, double a ):CPaintFrame( x, y, w, h ),aspect( a ),	IsRangeEnforced( false )
{
	x_description = "x values";
	y_description = "y values";
}

void CPlotXY::Paint( CGraphDevice &gDV )
{
	if ( !lines.size() ) return;

	unsigned k;
 
//   gDV.Rectangle( xs(0), ys(0), xs(100.0), ys( aspect * 100.0 ) ); // - for testing only
    
    double tscale = scale(), v_size, h_size, plot_height = 100 * aspect, ox, oy, vx, plot_area_width, plot_area_height, arrow = 5.0;

//dimension calculation

    gDV.AssignFont("Arial", scale( setup.value_font_height ) );
    h_size = gDV.GetTextWidth( x_description.c_str() ) / tscale;
    v_size = gDV.GetTextWidth( y_description.c_str() ) / tscale;

    CMaxMin maxs( 2 );
    vector< CPlotLine >::const_iterator i;
    for (i=lines.begin(); i!=lines.end(); ++i) i->UpdateMax( maxs );

	if ( IsRangeEnforced )
	{
		maxs.SetMin( 0, rmin );
		maxs.SetMax( 0, rmax );
	}

	vector<double> v1, v2;
	for (k=0; k<=setup.div_x; k++) v1.push_back(  maxs.GetMin( 0 ) + k * ( maxs.GetDiff( 0 ) / (double)setup.div_x )  );
	for (k=0; k<=setup.div_y; k++) v2.push_back(  maxs.GetMin( 1 ) + k * ( maxs.GetDiff( 1 ) / (double)setup.div_y )  );


// axial data

	oy = setup.by + setup.desc_font_height + setup.ny + setup.value_font_height + setup.amy;
	if ( setup.has_scale_y ) vx = write_set_vertically( setup.bx + setup.desc_font_height + setup.nx, oy , plot_height - setup.ey,  setup.vy_frm , v2 , gDV, setup.scale_y_significand_digit_paint );
	else vx = 0.0;
	ox = setup.bx + setup.desc_font_height + setup.nx + vx + setup.amx;
	plot_area_width = 100 - setup.ex - ox;
	plot_area_height = plot_height - oy - setup.ey;

   	write_set_horizontally( setup.bx + setup.desc_font_height + setup.nx + vx + setup.amx ,
	                        setup.by + setup.desc_font_height + setup.ny  , 100 - setup.ex, setup.vx_frm, v1 , gDV, setup.scale_x_significand_digit_paint );



    gDV.AssignFont( "Arial", scale( setup.desc_font_height ) );
    gDV.Write2D( xs( ox + ( 100 - setup.ex - ox - h_size ) / 2.0   ), ys( setup.by ), x_description.c_str() );
//    gDV.WriteVerically( xs( setup.bx + setup.desc_font_height ), ys( oy + ( plot_height - setup.ey - oy - v_size ) ), y_description.c_str() );
    gDV.WriteVerically2D( xs( setup.bx + setup.desc_font_height ), ys( oy  ), y_description.c_str() );

//arrows data used if type==PLT_XY_AXIS

    vector<DPoint2D> arr1,arr2;
    arr1.push_back( DPoint2D( xs( 100 - setup.ex ), ys( oy ) ) );
    arr1.push_back( DPoint2D( xs( 100 - setup.ex - arrow), ys( oy - arrow / 5.0 ) ) );
    arr1.push_back( DPoint2D( xs( 100 - setup.ex - arrow), ys( oy + arrow / 5.0 ) ) );

    arr2.push_back( DPoint2D( xs( ox ), ys( plot_height - setup.ey ) ) );
    arr2.push_back( DPoint2D( xs( ox - arrow / 5.0 ) , ys( plot_height - setup.ey - arrow ) ) );
    arr2.push_back( DPoint2D( xs( ox + arrow / 5.0 ) , ys( plot_height - setup.ey - arrow ) ) );


// axies painting

    switch(setup.type)
    {
        case PLT_XY_AXIS	: //gDV.Rectangle( xs( ox ), ys( oy ), xs( 100 - ex ), ys( 100 * aspect - ey )  );
                                gDV.Line2D( xs( ox ), ys( oy ), xs( 100 - setup.ex ), ys( oy ) );
                                gDV.Line2D( xs( ox ), ys( oy ), xs( ox ), ys( plot_height - setup.ey ) );
								gDV.SetPredefinedBrush( BRUSH_SOLID_BLACK );
                                gDV.Polygon2D( arr1 );
                                gDV.Polygon2D( arr2 );
                	            break;
		case PLT_FRAME1 :       gDV.SetPredefinedPen( PEN_THICK_DARKGRAY );
								gDV.Rectangle( xs( ox ), ys( oy ), xs( 100 - setup.ex ), ys( plot_height - setup.ey ) );
								gDV.SetPredefinedPen( PEN_DARKGRAY );
		                        for (k=1; k<setup.div_x; k++)
                                    gDV.Line2D( xs( ox + k * plot_area_width / (double) setup.div_x  ), ys( oy ), xs( ox + k * plot_area_width / (double) setup.div_x  ), ys( plot_height - setup.ey ) );
			                    for (k=1; k<setup.div_y; k++)
                                    gDV.Line2D( xs( ox ), ys( oy + k * plot_area_height / (double) setup.div_y), xs( 100 - setup.ex ), ys( oy + + k * plot_area_height / (double) setup.div_y ) );
								break;
		case PLT_FRAME2 :       gDV.Rectangle( xs( ox ), ys( oy ), xs( 100 - setup.ex ), ys( plot_height - setup.ey ) );
								for (k=1; k<setup.div_x; k++)
								{
                                    gDV.Line2D( xs( ox + k * plot_area_width / (double) setup.div_x  ), ys( oy ), xs( ox + k * plot_area_width / (double) setup.div_x   ), ys( oy + 2.0 ) );
                                    gDV.Line2D( xs( ox + k * plot_area_width / (double) setup.div_x  ), ys( plot_height- setup.ey ), xs( ox + k * plot_area_width / (double) setup.div_x ), ys( plot_height - setup.ey - 2.0 ) );
								}
			                    for (k=1; k<setup.div_y; k++)
			                    {
                                    gDV.Line2D( xs( ox ), scale( oy + k * plot_area_height / (double) setup.div_y), xs( ox + 2.0 ), scale( oy + + k * plot_area_height / (double) setup.div_y ) );
                                    gDV.Line2D( xs( 100 - setup.ex - 2.0 ), ys( oy + k * plot_area_height / (double) setup.div_y), xs( 100 - setup.ex ), ys( oy + + k * plot_area_height / (double) setup.div_y ) );
								}
								break;
        case PLT_ASCETIC :	   gDV.Line2D( xs( ox ), ys( oy ), xs( 100 - setup.ex ), ys( oy )  );
								for (k=0; k<=setup.div_x; k++)
								{
                                    gDV.Line2D( xs( ox + k * plot_area_width / (double) setup.div_x  ), ys( oy ), xs( ox + k * plot_area_width / (double) setup.div_x   ), ys( oy - 0.75 ) );
								//	gDV.Line( xs( ox + k * plot_area_width / (double) setup.div_x  ), ys( plot_height- setup.ey ), xs( ox + k * plot_area_width / (double) setup.div_x ), ys( plot_height - setup.ey - 2.0 ) );
								}
		default 			: break;
	}


// lines plot

	double x, y, xp, yp;

    Transformation tr( maxs, plot_area_width, plot_area_height );
	
	unsigned n = (unsigned)lines.size(), l;
	
	for (k=0; k<n; k++)
		if ( lines[ k ].GetSetup( ).has_line )
		{
			gDV.SetPen( lines[ k ].GetSetup( ).line_pen );
			lines[ k ].GetPoint( 0, xp, yp );
			for (l=1; l<lines[ k ].N(); l++)
			{
				lines[ k ].GetPoint( l, x, y );
                if ( !IsRangeEnforced || IsRangeEnforced && x < rmax && xp < rmax ) gDV.Line2D( xs( ox + tr.ex( xp ) ), ys( oy + tr.ey( yp ) ), xs( ox + tr.ex( x ) ), ys( oy + tr.ey( y ) ) );
				xp = x; yp = y;
			}
		}

    double lx,ly, r1=0.2, r=0.4;
	
    for (k=0; k<n; k++)
		if ( lines[ k ].GetSetup( ).point_type != PT_NOTHING )
		{
			gDV.SetPen( lines[ k ].GetSetup( ).point_pen );
			for (l=1; l<lines[ k ].N(); l += lines[ k ].GetSetup( ).point_freq )
			{
				lines[ k ].GetPoint( l, lx, ly );
                PlotPoint( gDV, ox + tr.ex( lx ), oy + tr.ey( ly ), lines[ k ].GetSetup( ).point_type );
			}
		}
		
// Paint lines description

    if ( !setup.has_description ) return; //PaintLineDescription( gDV, ox, oy, tr );

	double m1 = 0.5, pat = 3, m2 = 1.0, maxlen = 0.0, ds_width, ds_height, dfn_height = setup.lines_font_height, lhf= 1.5, wd;

    gDV.AssignFont("Arial", scale( dfn_height ) );

    vector< CPlotLine* > desclines;

    for (k=0; k<lines.size(); k++)
	    if ( lines[ k ].GetDescription().length() != 0 ) desclines.push_back( (CPlotLine*)&lines.at( k ) );

    for (k=0; k<desclines.size(); k++)
	{
		wd = gDV.GetTextWidth( desclines[ k ]->GetDescription().c_str() ) / scale();
		if ( wd > maxlen ) maxlen = wd;
	}

	if ( maxlen == 0.0 ) return;


	ds_width  = 2.0 * m1 + pat + m2 + maxlen;
	ds_height = 2.0 * m1 + desclines.size() * dfn_height * lhf;

	double x_pos = setup.desc_x + ox, y_pos = setup.desc_y + oy;
	DPoint2D pos(0.0,0.0),ddim( ds_width, ds_height ),pla_dim( plot_area_width, plot_area_height );

	if ( setup.find_desc_pos )
	{
	    if ( FindDescriptionPos( pos, ddim, pla_dim, tr ) )
    	{
			pos.GetXY ( x_pos, y_pos );
			x_pos += ox;
			y_pos += oy;
		}
	}

	gDV.SetPredefinedBrush( BRUSH_SOLID_WHITE );
	gDV.SetPredefinedPen( BLACK );
	gDV.Rectangle( xs( x_pos ), ys( y_pos ), xs( x_pos + ds_width ), ys( y_pos + ds_height ) );
	gDV.SetHollowBrush();

	for (k=0; k<desclines.size(); k++)
   	{
		gDV.SetPen( desclines[ k ]->GetSetup( ).line_pen );
        gDV.Line2D( xs( x_pos + m1 ), ys( y_pos + m1 + ( k + 0.5 ) * dfn_height * lhf ), xs( x_pos + m1 + pat  ), ys( y_pos + m1 + ( k + 0.5 ) * dfn_height * lhf ) );
		gDV.SetPen( desclines[ k ]->GetSetup( ).point_pen );
		PlotPoint( gDV, x_pos + m1 + pat / 2.0, y_pos + m1 + ( k + 0.5 ) * dfn_height * lhf  , desclines[ k ]->GetSetup( ).point_type );
        gDV.Write2D( xs( x_pos + m1 + pat + m2 ), ys( y_pos + m1 +  ( k + 0.25 )  * dfn_height * lhf ), desclines[ k ]->GetDescription().c_str() );
	}

	gDV.SetHollowBrush();
}


// No description
void CPlotXY::PlotPoint(CGraphDevice &gDV, double x, double y, unsigned  type) const
{
    double r1 = 0.002, r = 0.4;
	switch( type )
	{
				    case PT_RECT   : gDV.Rectangle( xs(x-r), ys(y-r), xs(x+r), ys( y+r ) );  break;
                    case PT_CARO   : gDV.Line2D( xs(x), ys(y-r), xs(x+r), ys( y ) );
                                     gDV.Line2D( xs(x+r), ys(y), xs(x), ys( y+r ) );
                                     gDV.Line2D( xs(x), ys(y+r), xs(x-r), ys( y ) );
                                     gDV.Line2D( xs(x-r), ys(y), xs(x), ys( y-r ) );
									 break;
                    case PT_TRIG   : gDV.Line2D( xs(x), ys(y+r), xs(x-r), ys( y-r ) );
                                     gDV.Line2D( xs(x), ys(y+r), xs(x+r), ys( y-r ) );
                                     gDV.Line2D( xs(x-r), ys(y-r), xs(x+r), ys( y-r ) );
									 break;
				    case PT_CIRC   : gDV.Ellipse( xs(x-r), ys(y-r), xs(x+r), ys( y+r ) );break;
				    case PT_DOT    : gDV.Ellipse( xs(x-r1), ys(y-r1), xs(x+r1), ys( y+r1 ) ); break;
                    case PT_CROSS  : gDV.Line2D( xs(x), ys(y+r), xs(x), ys( y-r ) );
                                     gDV.Line2D( xs(x-r), ys(y), xs(x+r), ys( y ) );
									 break;
                    case PT_X      : gDV.Line2D( xs(x-r), ys(y-r), xs(x+r), ys( y+r ) );
                                     gDV.Line2D( xs(x+r), ys(y-r), xs(x-r), ys( y+r ) );
									 break;
					case PT_NOTHING: break; 
					default : assert(0);
	}
}

// No description
bool CPlotXY::CheckPointInside(const DPoint2D p0, const DPoint2D &dim ) const
{
	unsigned k, l, n = (unsigned)lines.size();
	DPoint2D pk = p0 + dim, p;
	for (k=0; k<n; k++)
		for (l=0; l<lines[ k ].N(); l++)
		{
			lines[ k ].GetPoint( l, p );
		    if ( ( p.GetX() > p0.GetX() ) && ( p.GetX() < pk.GetX() ) && ( p.GetY() > p0.GetY() ) && ( p.GetY() < pk.GetY() ) ) return true;
		}
	return false;
}


// Procedure try to find suitable position for line description
bool CPlotXY::FindDescriptionPos( DPoint2D &pos, const DPoint2D &ds_dim, const DPoint2D &pla_dim, const Transformation &tr) const
{
	double  plot_area_width = pla_dim.GetX(),plot_area_height =  pla_dim.GetY();
	double  ds_width = ds_dim.GetX(), ds_height =  ds_dim.GetY();
    double  x1 = 0.5, y1 = 0.5 , x2 = plot_area_width - ds_width - 0.5, y2 = plot_area_height - ds_height  - 0.5;
    double  xs = ( x1 + x2 ) / 2.0, ys = ( y1 + y2 ) / 2.0;

	if ( !LineSearchDescriptionPos( pos, ds_dim, tr.TransformPointToReal( DPoint2D( x1, y2 )  ), tr.TransformPointToReal( DPoint2D( x2, y2 ) ), tr ) )
	{
		if ( !LineSearchDescriptionPos( pos, ds_dim, tr.TransformPointToReal( DPoint2D( x1, y1 ) ), tr.TransformPointToReal( DPoint2D( x2, y1 ) ), tr ) )
		{
			if ( !LineSearchDescriptionPos( pos, ds_dim, tr.TransformPointToReal( DPoint2D( x1, ys ) ), tr.TransformPointToReal( DPoint2D( x2, ys ) ), tr ) )
			{
				if ( !LineSearchDescriptionPos( pos, ds_dim, tr.TransformPointToReal( DPoint2D( xs, y1 ) ), tr.TransformPointToReal( DPoint2D( xs, y2 ) ), tr ) )
				{
					if ( !LineSearchDescriptionPos( pos, ds_dim, tr.TransformPointToReal( DPoint2D( x1, y1 ) ), tr.TransformPointToReal( DPoint2D( x2, y2 ) ), tr ) )
					{
						if ( !LineSearchDescriptionPos( pos, ds_dim, tr.TransformPointToReal( DPoint2D( x1, y2 ) ), tr.TransformPointToReal( DPoint2D( x2, y1 ) ), tr ) )
						{
							return false;
						}
					}
				}
			}
		}

	}
	
	return true;
}

// No description
bool CPlotXY::LineSearchDescriptionPos(DPoint2D &pos, const DPoint2D &ddim, const DPoint2D &x1, const DPoint2D &x2,const Transformation &tr) const
{
	DPoint2D mm = pos;
	unsigned div = 10,k;
	DPoint2D rdim( ddim.GetX() / tr.cx, ddim.GetY() / tr.cy ),p, dp = (x2 - x1) / (double)div;

	for( k=0; k<div; k++)
	{
		p = x1 + k * dp;
		if ( !CheckPointInside( p, rdim ) ) { pos = tr.TransformPointToPlot( p );  return true; }
	}
	
	pos = mm;
	return false;
}
